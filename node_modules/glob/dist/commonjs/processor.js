"use strict";
// synchronous utility for filtering entries and calculating subwalks
Object.defineProperty(exports, "__esModule", { value: true });
exports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;
const minimatch_1 = require("minimatch");
/**
 * A cache of which patterns have been processed for a given Path
 */
class HasWalkedCache {
    store;
    constructor(store = new Map()) {
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
            cached.add(pattern.globString());
        else
            this.store.set(fullpath, new Set([pattern.globString()]));
    }
}
exports.HasWalkedCache = HasWalkedCache;
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */
class MatchRecord {
    store = new Map();
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [...this.store.entries()].map(([path, n]) => [
            path,
            !!(n & 2),
            !!(n & 1),
        ]);
    }
}
exports.MatchRecord = MatchRecord;
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */
class SubWalks {
    store = new Map();
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find(p => p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        }
        else
            this.store.set(target, [pattern]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */
        if (!subs) {
            throw new Error('attempting to walk unknown path');
        }
        /* c8 ignore stop */
        return subs;
    }
    entries() {
        return this.keys().map(k => [k, this.store.get(k)]);
    }
    keys() {
        return [...this.store.keys()].filter(t => t.canReaddir());
    }
}
exports.SubWalks = SubWalks;
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */
class Processor {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache
            ? hasWalkedCache.copy()
            : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map(p => [target, p]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet) {
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === '/' && this.opts.root !== undefined
                    ? this.opts.root
                    : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                }
                else {
                    pattern = rest;
                }
            }
            if (t.isENOENT())
                continue;
            let p;
            let rest;
            let changed = false;
            while (typeof (p = pattern.pattern()) === 'string' &&
                (rest = pattern.rest())) {
                const c = t.resolve(p);
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                    continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === 'string') {
                // must not be final entry, otherwise we would have
                // concatenated it earlier.
                const ifDir = p === '..' || p === '' || p === '.';
                this.matches.add(t.resolve(p), absolute, ifDir);
                continue;
            }
            else if (p === minimatch_1.GLOBSTAR) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() ||
                    this.follow ||
                    pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === '' || rp === '.');
                }
                else {
                    if (rp === '..') {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */
                        const tp = t.parent || t;
                        /* c8 ignore stop */
                        if (!rrest)
                            this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            }
            else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries) {
            for (const pattern of patterns) {
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === minimatch_1.GLOBSTAR) {
                    results.testGlobstar(e, pattern, rest, absolute);
                }
                else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                }
                else {
             Šğ  éBù¶ÿHŠ°  éú.“ÿHŠÀ  éî.“ÿHŠà  éâ.“ÿHŠh  éù¶ÿHŠX  éù¶ÿHŠ(  é¾.“ÿHŠ  éY‰ÿHŠ   éY‰ÿHŠ°  éºS·ÿHŠĞ  é¾]ˆÿHŠØ  é‚)ˆÿHŠ€   ér—˜ÿHŠ€   éf—˜ÿHŠx  é^)ˆÿHŠÀ  éR)ˆÿ@UHƒì H‹ê‹EXƒà…ÀtƒeXşH   è/)ˆÿHƒÄ ]Ã@UHƒì H‹ê‹EXƒà…ÀtƒeXıHP  è)ˆÿHƒÄ ]ÃHŠ   éô(ˆÿHŠ   éè(ˆÿHŠp  éØ–˜ÿHŠ8  éĞ(ˆÿHŠĞ   éÄ(ˆÿHŠÀ  é´–˜ÿHŠ  é¨–˜ÿHŠà  é (ˆÿHŠ   é”(ˆÿHŠ`  é„–˜ÿHŠp   é¬\ˆÿHŠ¸  éÀ(ˆÿHŠ8  éd(ˆÿH‹Š`   édš‹ÿH‹Š`   éòÅÿHŠX  é@(ˆÿHŠ(  édMšÿHŠP  é(-“ÿHŠ¨  é-“ÿHŠP   é(ˆÿHŠP   é(ˆÿHŠ`  éø'ˆÿHŠÀ   é<(ˆÿHŠ   éà'ˆÿHŠP   é$(ˆÿHŠà   éÈ'ˆÿHŠ    é(ˆÿHŠ    é°'ˆÿHŠP   éô'ˆÿHŠP   éè'ˆÿHŠ°   éÜ'ˆÿHŠp   éĞ'ˆÿHŠĞ   éÄ'ˆÿ@UHƒì H‹ê‹EPƒà…ÀtƒePşHM`è„[ˆÿHƒÄ ]ÃHŠğ   éB'ˆÿHŠ   é†'ˆÿH‹ŠX   é6™‹ÿH‹ŠX   éêğÅÿH‹ŠX   HÁ˜  é'ˆÿH‹ŠX   HÁÀ  é([ˆÿHŠ  éì&ˆÿHŠğ   é0'ˆÿHŠp   é$'ˆÿHŠğ   é'ˆÿH‹Š`   éÈ˜‹ÿHŠğ   é 'ˆÿHŠp   é¤&ˆÿHŠğ   é˜&ˆÿHŠp   éÜ&ˆÿHŠp   éĞ&ˆÿHŠğ   éÄ&ˆÿHŠh   é¸&ˆÿHŠ   é¬&ˆÿHŠh   é &ˆÿHŠ°   éD&ˆÿHŠ   éˆ&ˆÿHŠh   é|&ˆÿHŠ   ép&ˆÿHŠ   é&ˆÿHŠ   é&ˆÿHŠh   éü%ˆÿHŠ°   éğ%ˆÿHŠh   éä%ˆÿHŠ   é(&ˆÿHŠp   éÌ%ˆÿHŠ@   é&ˆÿHŠĞ   éU‰ÿHŠà   é”*“ÿHŠ   é @¶ÿHŠp   éà%ˆÿHŠ°   é„%ˆÿHŠ@   éÈ%ˆÿHŠp   é¼%ˆÿHŠp   é°%ˆÿHŠp   é¤%ˆÿHŠp   é˜%ˆÿHŠp   éŒ%ˆÿHŠp   é€%ˆÿHŠà   é<VœÿHŠÀ   é%ˆÿHŠà   é$VœÿHŠÀ   é %ˆÿHŠÀ   éô$ˆÿHŠ    éU‰ÿHŠø   éÜ$ˆÿHŠ€   éĞ$ˆÿHŠX   éÄ$ˆÿHŠX   é¸$ˆÿHŠX   é¬$ˆÿHŠX   é $ˆÿHŠÀ  é”$ˆÿHŠ`   é UœÿHŠ@   é|$ˆÿHŠÀ   ép$ˆÿHŠh   éd$ˆÿHŠÀ   éX$ˆÿHŠh   éL$ˆÿHŠh   é@$ˆÿHŠp   é4$ˆÿHŠp   é($ˆÿHŠÈ   é$ˆÿHŠÈ   é$ˆÿHŠ¨   é4XˆÿHŠ˜   é(XˆÿHŠp   é<$ˆÿHŠP   é0$ˆÿHŠ0   é$$ˆÿH‹Š    é”íÅÿH‹Š    HÁ˜  é%H‰ÿHŠ   éH‰ÿHŠ   éÁ…‰ÿH‹Š   é•‹ÿHŠÀ   Hÿ%Û{ HŠ0  éÇ#ˆÿHŠ`  é»#ˆÿHŠp   é¯#ˆÿHŠ   é£#ˆÿHŠ@   é—#ˆÿHŠ@   é‹#ˆÿHŠ@   é#ˆÿHŠ@   é#(“ÿHŠ0   é·‘ÿHŠP   é[#ˆÿHŠ˜   é_R‰ÿHŠ˜   éC#ˆÿHŠà   éÓ'“ÿHŠ   HƒÁé7R‰ÿHŠ   HƒÁé‡F‰ÿHŠ   é›×ˆÿHŠP   éÿ"ˆÿHŠ€   Hÿ%ùz HŠ    é­ˆ˜ÿHŠ`   ééQ‰ÿHŠP   éyl‹ÿHŠ   éq"ˆÿHŠp   éµ"ˆÿHŠP   é©"ˆÿHŠP   é"ˆÿH‹Šp   éM”‹ÿHŠP   é…"ˆÿH‹Šp   é5”‹ÿHŠP   ém"ˆÿHŠP   éa"ˆÿHŠ€   Hÿ%[z H‹Š(   HƒÁé{‰ÿH‹Š(   HƒÁ é»ëÏÿH‹Š(   HƒÁXéVˆÿH‹Š    HƒÁéo¸ÿH‹Š    HƒÁésE‰ÿH‹Š(   HƒÁhé£š·ÿH‹Š(   HÁ¨   éÀUˆÿHŠ  émÿHŠ   éRœÿHŠ@   éDëÏÿ@UHƒì H‹êº   H‹M èÕKöÿHƒÄ ]ÃHŠP   é“mÿHŠ@   égUˆÿH‹ŠĞ  é[UˆÿHŠØ  é+mÿHŠ@   éƒE‰ÿHŠˆ   éwE‰ÿHŠ`   émÿHŠP   éUˆÿHŠ    éïlÿHŠ`  éãlÿHŠP  éûTˆÿHŠ    émÿHŠĞ   éP‰ÿHŠğ   é¿QœÿHŠÀ   éËTˆÿHŠà   é›lÿHŠ€   éÓ ˆÿHŠ@   éÇ ˆÿHŠ    é» ˆÿHŠ`   é¯ ˆÿHŠ  éËñˆÿHŠ0  é§O‰ÿHŠĞ   éSQœÿHŠP  élÿHŠ@  éSTˆÿHŠ  ésy“ÿHŠ¨   é[ ˆÿHŠˆ   éO ˆÿHŠ
'use strict';

const util = require('util');
const braces = require('braces');
const picomatch = require('picomatch');
const utils = require('picomatch/lib/utils');
const isEmptyString = val => val === '' || val === './';

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} `list` List of strings to match.
 * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `[options]` See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));

  for (let item of items) {
    if (!matches.has(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list,h²Ç!şÉgptI`#VÂƒ[bsBaa±É˜0Ùo·ÌÚ™‘lA4äµÎ#:f2í:Ã‡#äGıÛ†Şa>’±»Æ	O°pÍ‰¡M!0zO&sç#¤øïµSã&œŠBSĞ"j§ÖÏ>ÂÓÄu :gPAn¼ÌÀ7)¹õ€ï¥ÕHÏ$ÕI¼•pÍÇ†Œ½57!ö<JfQ6&²m‡-w‚Íí9ğ£vAº4Î5ˆõ+õÄœB™˜P^ğ
û¶»HX¢pÒ–„æáŠãòC84uxumGuÇ§ã‡!“As5_ÔI§Øå_Æı™…JW
¼ô™îWN0İãîÇÌWw~î0à¤¼úÏsjêÀK÷$8p@ˆ„H«¾"Ò‚B%´¨Éjğ¾ËPJMãFi ¼õ,V¹ÄªîàøD„ËÄë~SPƒ´)+=RF¥í¨9bÁ©ÇyúM3PZ”òÄõ[‚…¹åw^Ó» õr)–{IuZ«Ï’èëæ<ùZs™¯Æª?;­SáÑ½e ¯®jH¡¢:¡\³k1‰ü€¬6'¬HÃ§ ß*¶Ş«¯Ä54¡ŠŠ(¡_ŒÚ—"akœäX¿¦Ïu…Ó˜Ø+e¢É:@×õ‘­(†où‚“O¹‘»R¸ü=:œ0¯í¥’]²ê?—`€`RÏ¢Ëè3ğº„ôZ5çò&nĞrÈ_]!MÉêŒ& W$}´†Ê¶PÙ¶<g;‘€¿†ÁùÊM¿‹æ}X¢«{_b…‘[Ò÷<úöA„j…È´&¸v²‹,fSÙHŸ-!;{Ñ•r‹¼Ü÷,<uµ+À7T»¾V(×U_²’g“×
t¤Œ–”°•¡	şW¶qû¦Xù‹‘S± “¯Äãø+º8^LÈÍØ> \Û ^†óì‹ÌBF8\¸Sı€Nx45I¿°¬1´7ıÊ®ğfá
1ßX®Wj'v,O»è#9­RdŸ¬DrùÕîÑ˜Ğçæ¢Å§t¸CºÚ+h°I>³¼™Ä4û†*3‘ÓBÇdÄµöì'ôoá'6Õ¦XÌÓ›ĞY#ñÊ"+4ßz?ƒÆ¬±Bz¥jÀnBS—aá·tbc¬í4sÂ‡VìoÅ.{["?èKê6[êŞHUê·z@ @ÚaxÈ´ÙŒÁ«˜ƒÓró½¼r²G”2,%Iº&ëşµè%-ˆ# z›6p8“ÇæÔÇ‘½	vº%òo´0Ëúú;9O•æT­ÉFÍ]•¹ûBÍöbéé™Á¥Ïkİ‹ Â33ÙKç5!@å½‚apÛ£/ÿ »ÉÎ@4^é>"‘4i^ê 'µ}nÜa0©kÛú–ÖãR4)lÛşø»F Jë¤§[m
’ñ½#Ó`B‰¼~_‚”iw0©éá5'g{n ö¦ºİi7ĞãY•0ôÿ@…qy¦ÖôqXÙxf|D-¬ÒtÌwßq˜¢ëĞ_€éDé#|}şTøzöÓëêlŠ?v‚!ëIj¬#ÂŠSeU‚”QiÜ¸NV"Ô–¼ö†EIæª8&×Ïô4PìjãN“8XU¥¡Rš%/·Y‚*U¿ÛÜ`®nÒOirÏƒ\UDCÊÑŠù«_c$aé†ªÄ—`¯Nï˜J4Ó½M!ĞçäAÿ¾jØ_ïzØÔ^¼qGì“™@æcqÅ,ƒ/Gâ„çš¶7uÁ05i•ĞÈ¶.27î”1&	32şßjàj=G"-¤ıËcxïvZ—ˆ¬õâ*•:3
ÌÈ1æx€±îİ2ıQA²*|x%-ò“8ïR­G#$QTÅ™l¢kE·èİ¸üÜ–Ê–qJT1œµĞÏ>S¨Ä`dvw>8õHò“m@MiIë›êWshqÒ}çuğxF““¥a‹ç9 ÓòáÏœ¸MÜğ&d`yÎ™
ì2Ÿ¶†…oJ™<¿°™[Åw‡RÍhØUİA”Í¹÷“±Ş’˜]Å—.İ<'}xW²P›á£»Í_&<ûåZ£ğóıÓ¾‹õ@•ú\šä¶í~nİş¦(öÄ¤¹×õm¼àÆÁ
¦´^‹Ô¨Ï§BñüYv*{®®EØNâñ®86ä†iİiÜ.&ˆ{ dXFœ‚—Û†N8†_Q.s`hé©.%L¿ƒ_“µHá)ÕŠ¿ÓUÍ‡*ú‘Câ
úê°ĞŒd¢as%!Ü2¹ñ«CpÕÕaBşµyo4´–¢´µÇMÃ­bwÓÌÓ¶yÊà0ôû¬™‘Ÿ*çãX´mÙn’DZÃà.Ëí4/ÂTìA”Ï	Ò‡-‡Ş‘@Öê}{åh¿€ûÅÙËşM
ıÆ›Pğ1²0ük]Nç§×Ë+p´¡T‘™"§vnjfˆ·,vTÔ›[: /o"¿ÆVñK‡AÕÊçÍ')·U5 áv‹1¸ßÊ,kKfåFc4±¥ôÊÜÆò^ÒGåµQœ€“‚ÄDÅïTiĞ$÷•a!Ü‚IR6–¨Hííš}é¯÷Æ5)®ù ¾—ìç´¼U¨&ÃÇ¬„Õ¾oR„[ªfÖ|l$õı	µ.Î¨y²ìã7ßü%Pz=e#îä™àz&ÅÌdœÜ#Kš©³á»¼·ïÀpé¶¦ĞüfI,›Ü8šŠ¼!OF–—K×½qu—¤ã;k*L–¼
Ÿ*_‰b#¥Å½NŸ{Íc­ñA µ˜)NGÆA%f/6R'µ¾'µú»úœDG¿{ìºıŒ€ï^}ê¥_lv(;Özz>=%Ã®4ßûáx?ªL¢	FÙ§9½’axÏSOƒçï‹x/ cÕéB´Kz¥¿”œ*;E  õ'
şÜ_VšúŸlÁûù»d!xãÌdµ¢?‘à+÷WB)ØĞYj´M!Ï+¤„á%.^m×’°DÁÁl1şÂ6À,€×	®5¨’<-+¢Ä°æ¾yßè ønı˜f{ë +»õ¿'èÒÿuèÖæÚf5óZI¤`
òÏA ÿ:şê§Ty<uÔ™e-Ò°’mS¶ìPJÓÙ§6ÿ rÓ=>$¬şì€sF~Å"ı‚ÿ
•™•ŸiR¢ôu.1f2†2¢:*ùNù5 Ø/6
š•1€éß²¼ki‹vÜ‹^•¦I•›ÎÑÅ–ÃÊ¬3Ú/®^‰¾QÌF´°…àæ}Eúèq‘]|I•uù2€o¸İÛDµ0ÚŒ\úÁÌr¿Ë³§·ôBáì?Şå,T€4ò†kü!Âƒ¬‡¹x„$œ…	ì‚0>Š ,”ÂkÛÛÊä®@»`DÓÑTøÒ¢µj^¨$­EŠY3rjD¨­	šÙI¹ãİâG•¢ZHgxíãŠ*ÊëÉ9)(RóP¯Wùbù¯dñC¦ïÇ0HîµŞ™à¾ı>Ñsâwÿ¤½i/|ÆÉûª 'øµ±™pÄ&>©æzUCœZäÄ¾’B¿QŠë7(ûu©a¦zpí‹àğ-WÎÿà×´¬×²¢,ÿöŠk-ÇñV»q¬P;Ü“‹#¹MôXÕ'óaKË\mVúÓ¸8­ Nåö£0ø/\èR!Ìö¥åÍ¿r¢V(;¢…ŞüJƒğ$¦‚-†Òk
Pü•/µMŸ|ãÑáà_´šØ(q5ïbNµÏÊ›ÛŞî‡ÖÛ²4q€ìc{Ğ„NËä ‹N»ü)g–3õt…N½ÄıŒŞni' ¼ı‘ÀéÔs¼@åù¡QèT½1ó¡—ZQ«´±V‡¢§Ì¯*â!¸›EhKÖ„¿‡\9+"£mwhŒÕ¦óQKN0Q‡¬3}âã?nÖ,"<¢'8ü·©ii Ş‚3J…VâÀ £7Ÿ«Ç)dµ;hØÒ<FÙ€7\™¾òHÿ™Ñ¨ `^ãE’<­£núLKAà¦U,öÃ“(¦ĞT=ÿ\-À°•b:”4SYˆÀS?¯w­ã9n• ™`=ˆ¤¯e"f
>Kä_óq—!ËùT<  ¬/Pò-óá™g a7ˆàH`¬Ù°ÎÈmÑ—R¡ŸP¸'5›p‘­yrœàpŸ+•8fÓ‚5#¦‘·şägœ+" aÓ=ÆNŸ'$›¦ğÚGFĞqlÌ%:üôîäÊ›’™uóG™Yÿ)QÇG1ıøÊVi‰Enª“Š»ì[¨M–Í¸ægĞÚU,®h‘Ån¸UˆBß>üqw3|dîşX_ëÿ¾Pt…Ú,à‘ş…EŠÇÙlñ˜54fãÇæ2ACË`ƒ€fl+È†VæÖ|*¸¼m:û”9 2:®’"¿¸Æ:¼mDeó‹¨o|Aån[[gãò™tyå$ö:X¯<Õ£töªûÄg|=NÌt±T_5ÿBe—¥3?ú83+lñGœÓÖà,†‘A…Ñ1À§Üh`).´õ2Ÿıöm0ÚT#VŒìµ‘O§Û±qÅ }HÎ
Šfí¯v¾ë4^âà¦223ª>ì`UÓõ¥RV ¦ù¨-^ªMù+°<µ;³€µ0±óñ{~€¢äJf‘Wåí.ªfÉÄ&›'¿v{Ú\âvb-½¸)­³’¢:1¥å€mSÚçì§V@X™óÅö’ÄÂØeJ
‚Î@Öf{q3I:Ì12Y"I.|–şù¥“~‚ì7!õì›;;õ›\ĞôÀ(Í^!l%ÂV>WÅ^pUQXíî~±º‹¥²¯<ºãÔwgMªJ­Çè¬Ó8ıób/p_X]gß†û‡ÉÜ÷Ö^AŒk¥ˆöè¹ÕÇb÷aæ>|Úq€®ìŸñÉª&gÿâçc6?*±ş3aØ?7",ÔÇp^”Ú•i®Şû¬¾ª0$”{rŒº"8á°;wµÒ ¨V?¥P«£ZµØT“úÏ”K.ÉR|ÏšŸ—º4w¨%2iÙZ­sL½`Ÿ:l’Ç¿T;TıZ á·á; DáGaW0¼>Û–_ƒ™‰B¥`åğó÷ñ¿’ Hï„¶ašPŒç0Ô 9?a…ù¦aáõ¶wáAµyA[ZdAõxP8Àéš³v£¤É¥ï÷€İùÄ‘^z
ÓG(iú†öøğ¡"à®øÜ|ØñÉB¦1Î«¶@oWrÃáªá¥3ŞËà¾e€tÃµ¹kıİ_R3wPÿJ¨ºÚ’Ê^ZwwúH$—­ÑÂ®ú]í ì'°LÅpvìÎ=µñP$öÑüè
$³G–ÑÎKtøI…$°âT­¦ÕGJjÜ»K~Ä¯ @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

module.exports = micromatch;

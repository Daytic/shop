import postcss from 'postcss'
import parser from 'postcss-selector-parser'

import { resolveMatches } from './generateRules'
import escapeClassName from '../util/escapeClassName'
import { applyImportantSelector } from '../util/applyImportantSelector'
import { movePseudos } from '../util/pseudoElements'

/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */

function extractClasses(node) {
  /** @type {Map<string, Set<string>>} */
  let groups = new Map()

  let container = postcss.root({ nodes: [node.clone()] })

  container.walkRules((rule) => {
    parser((selectors) => {
      selectors.walkClasses((classSelector) => {
        let parentSelector = classSelector.parent.toString()

        let classes = groups.get(parentSelector)
        if (!classes) {
          groups.set(parentSelector, (classes = new Set()))
        }

        classes.add(classSelector.value)
      })
    }).processSync(rule.selector)
  })

  let normalizedGroups = Array.from(groups.values(), (classes) => Array.from(classes))
  let classes = normalizedGroups.flat()

  return Object.assign(classes, { groups: normalizedGroups })
}

let selectorExtractor = parser()

/**
 * @param {string} ruleSelectors
 */
function extractSelectors(ruleSelectors) {
  return selectorExtractor.astSync(ruleSelectors)
}

function extractBaseCandidates(candidates, separator) {
  let baseClasses = new Set()

  for (let candidate of candidates) {
    baseClasses.add(candidate.split(separator).pop())
  }

  return Array.from(baseClasses)
}

function prefix(context, selector) {
  let prefix = context.tailwindConfig.prefix
  return typeof prefix === 'function' ? prefix(selector) : prefix + selector
}

function* pathToRoot(node) {
  yield node
  while (node.parent) {
    yield node.parent
    node = node.parent
  }
}

/**
 * Only clone the node itself and not its children
 *
 * @param {*} node
 * @param {*} overrides
 * @returns
 */
function shallowClone(node, overrides = {}) {
  let children = node.nodes
  node.nodes = []

  let tmp = node.clone(overrides)

  node.nodes = children

  return tmp
}

/**
 * Clone just the nodes all the way to the top that are required to represent
 * this singular rule in the tree.
 *
 * For example, if we have CSS like this:
 * ```css
 * @media (min-width: 768px) {
 *   @supports (display: grid) {
 *     .foo {
 *       display: grid;
 *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
 *     }
 *   }
 *
 *   @supports (backdrop-filter: blur(1px)) {
 *     .bar {
 *       backdrop-filter: blur(1px);
 *     }
 *   }
 *
 *   .baz {
 *     color: orange;
 *   }
 * }
 * ```
 *
 * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:
 *
 * ```css
 * @media (min-width: 768px) {
 *   @supports (backdrop-filter: blur(1px)) {
 *     .bar {
 *       backdrop-filter: blur(1px);
 *     }
 *   }
 * }
 * ```
 *
 * @param {import('postcss').Node} node
 */
function nestedClone(node) {
  for (let parent of pathToRoot(node)) {
    if (node === parent) {
      continue
    }

    if (parent.type === 'root') {
      break
    }

    node = shallowClone(parent, {
      nodes: [node],
    })
  }

  return node
}

/**
 * @param {import('postcss').Root} root
 */
function buildLocalApplyCache(root, context) {
  /** @type {ApplyCache} */
  let cache = new Map()

  root.walkRules((rule) => {
    // Ignore rules generated by Tailwind
    for (let node of pathToRoot(rule)) {
      if (node.raws.tailwind?.layer !== undefined) {
        return
      }
    }

    // Clone what's required to represent this singular rule in the tree
    let container = nestedClone(rule)
    let sort = context.offsets.create('user')

    for (let className of extractClasses(rule)) {
      let list = cache.get(className) || []
      cache.set(className, list)

      list.push([
        {
          layer: 'user',
          sort,
          important: false,
        },
        container,
      ])
    }
  })

  return cache
}

/**
 * @returns {ApplyCache}
 */
function buildApplyCache(applyCandidates, context) {
  for (let candidate of applyCandidates) {
    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
      continue
    }

    if (context.classCache.has(candidate)) {
      context.applyClassCache.set(
        candidate,
        context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()])
      )
      continue
    }

    let matches = Array.from(resolveMatches(candidate, context))

    if (matches.length === 0) {
      context.notClassCache.add(candidate)
      continue
    }

    context.applyClassCache.set(candidate, matches)
  }

  return context.applyClassCache
}

/**
 * Build a cache only when it's first used
 *
 * @param {() => ApplyCache} buildCacheFn
 * @returns {ApplyCache}
 */
function lazyCache(buildCacheFn) {
  let cache = null

  return {
    get: (name) => {
      cache = cache || buildCacheFn()

      return cache.get(name)
    },
    has: (name) => {
      cache = cache || buildCacheFn()

      return cache.has(name)
    },
  }
}

/**
 * Take a series of multiple caches and merge
 * them so they act like one large cache
 *
 * @param {ApplyCache[]} caches
 * @returns {ApplyCache}
 */
function combineCaches(caches) {
  return {
    get: (name) => caches.flatMap((cache) => cache.get(name) || []),
    has: (name) => caches.some((cache) => cache.has(name)),
  }
}

function extractApplyCandidates(params) {
  let candidates = params.split(/[\s\t\n]+/g)

  if (candidates[candidates.length - 1] === '!important') {
    return [candidates.slice(0, -1), true]
  }

  return [candidates, false]
}

function processApply(root, context, localCache) {
  let applyCandidates = new Set()

  // Collect all @apply rules and candidates
  let applies = []
  root.walkAtRules('apply', (rule) => {
    let [candidates] = extractApplyCandidates(rule.params)

    for (let util of candidates) {
      applyCandidates.add(util)
    }

    applies.push(rule)
  })

  // Start the @apply process if we have rules with @apply in them
  if (applies.length === 0) {
    return
  }

  // Fill up some caches!
  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)])

  /**
   * When we have an apply like this:
   *
   * .abc {
   *    @apply hover:font-bold;
   * }
   *
   * What we essentially will do is resolve to this:
   *
   * .abc {
   *    @apply .hover\:font-bold:hover {
   *      font-weight: 500;
   *    }
   * }
   *
   * Notice that the to-be-applied class is `.hover\:font-bold:hover` and that the utility candidate was `hover:font-bold`.
   * What happens in this function is that we prepend a `.` and escape the candidate.
   * This will result in `.hover\:font-bold`
   * Which means that we can replace `.hover\:font-bold` with `.abc` in `.hover\:font-bold:hover` resulting in `.abc:hover`
   *
   * @param {string} selector
   * @param {string} utilitySelectors
   * @param {string} candidate
   */
  function replaceSelector(selector, utilitySelectors, candidate) {
    let selectorList = extractSelectors(selector)
    let utilitySelectorsList = extractSelectors(utilitySelectors)
    let candidateList = extractSelectors(`.${escapeClassName(candidate)}`)
    let candidateClass = candidateList.nodes[0].nodes[0]

    selectorList.each((sel) => {
      /** @type {Set<import('postcss-selector-parser').Selector>} */
      let replaced = new Set()

      utilitySelectorsList.each((utilitySelector) => {
        let hasReplaced = false
        utilitySelector = utilitySelector.clone()

        utilitySelector.walkClasses((node) => {
          if (node.value !== candidateClass.value) {
            return
          }

          // Don't replace multiple instances of the same class
          // This is theoretically correct but only partially
          // We'd need to generate every possible permutation of the replacement
          // For example with `.foo + .foo { … }` and `section { @apply foo; }`
          // We'd need to generate all of these:
          // - `.foo + .foo`
          // - `.foo + section`
          // - `section + .foo`
          // - `section + section`
          if (hasReplaced) {
            return
          }

          // Since you can only `@apply` class names this is sufficient
          // We want to replace the matched class name with the selector the user is using
          // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`
          node.replaceWith(...sel.nodes.map((node) => node.clone()))

          // Record that we did something and we want to use this new selector
          replaced.add(utilitySelector)

          hasReplaced = true
        })
      })

      // Sort tag names before class names (but only sort each group (separated by a combinator)
      // separately and not in total)
      // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`
      for (let sel of replaced) {
        let groups = [[]]
        for (let node of sel.nodes) {
          if (node.type === 'combinator') {
            groups.push(node)
            groups.push([])
          } else {
            let last = groups[groups.length - 1]
            last.push(node)
          }
        }

        sel.nodes = []

        for (let group of groups) {
          if (Array.isArray(group)) {
            group.sort((a, b) => {
              if (a.type === 'tag' && b.type === 'class') {
                return -1
              } else if (a.type === 'class' && b.type === 'tag') {
                return 1
              } else if (a.type === 'class' && b.type === 'pseudo' && b.value.startsWith('::')) {
                return -1
              } else if (a.type === 'pseudo' && a.value.startsWith('::') && b.type === 'class') {
                return 1
              }

              return 0
            })
          }

          sel.nodes = sel.nodes.concat(group)
        }
      }

      sel.replaceWith(...replaced)
    })

    return selectorList.toString()
  }

  let perParentApplies = new Map()

  // Collect all apply candidates and their rules
  for (let apply of applies) {
    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source]

    perParentApplies.set(apply.parent, [candidates, apply.source])

    let [applyCandidates, important] = extractApplyCandidates(apply.params)

    if (apply.parent.type === 'atrule') {
      if (apply.parent.name === 'screen') {
        let screenType = apply.parent.params

        throw apply.error(
          `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates
            .map((c) => `${screenType}:${c}`)
            .join(' ')} instead.`
        )
      }

      throw apply.error(
        `@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`
      )
    }

    for (let applyCandidate of applyCandidates) {
      if ([prefix(context, 'group'), prefix(context, 'peer')].includes(applyCandidate)) {
        // TODO: Link to specific documentation page with error code.
        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`)
      }

      if (!applyClassCache.has(applyCandidate)) {
        throw apply.error(
          `The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`
        )
      }

      let rules = applyClassCache.get(applyCandidate)

      // Verify that we can apply the class
      for (let [, rule] of rules) {
        if (rule.type === 'atrule') {
          continue
        }

        rule.walkRules(() => {
          throw apply.error(
            [
              `The \`${applyCandidate}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,
              'Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:',
              'https://tailwindcss.com/docs/using-with-preprocessors#nesting',
            ].join('\n')
          )
        })
      }

      candidates.push([applyCandidate, important, rules])
    }
  }

  for (let [parent, [candidates, atApplySource]] of perParentApplies) {
    let siblings = []

    for (let [applyCandidate, important, rules] of candidates) {
      let potentialApplyCandidates = [
        applyCandidate,
        ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator),
      ]

      for (let [meta, node] of rules) {
        let parentClasses = extractClasses(parent)
        let nodeClasses = extractClasses(node)

        // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`
        // So we've split them into groups
        nodeClasses = nodeClasses.groups
          .filter((classList) =>
            classList.some((className) => potentialApplyCandidates.includes(className))
          )
          .flat()

        // Add base utility classes from the @apply node to the list of
        // classes to check whether it intersects and therefore results in a
        // circular dependency or not.
        //
        // E.g.:
        // .foo {
        //   @apply hover:a; // This applies "a" but with a modifier
        // }
        //
        // We only have to do that with base classes of the `node`, not of the `parent`
        // E.g.:
        // .hover\:foo {
        //   @apply bar;
        // }
        // .bar {
        //   @apply foo;
        // }
        //
        // This should not result in a circular dependency because we are
        // just applying `.foo` and the rule above is `.hover\:foo` which is
        // unrelated. However, if we were to apply `hover:foo` then we _did_
        // have to include this one.
        nodeClasses = nodeClasses.concat(
          extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)
        )

        let intersects = parentClasses.some((selector) => nodeClasses.includes(selector))
        if (intersects) {
          throw node.error(
            `You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`
          )
        }

        let root = postcss.root({ nodes: [node.clone()] })

        // Make sure every node in the entire tree points back at the @apply rule that generated it
        root.walk((node) => {
          node.source = atApplySource
        })

        let canRewriteSelector =
          node.type !== 'atrule' || (node.type === 'atrule' && node.name !== 'keyframes')

        if (canRewriteSelector) {
          root.walkRules((rule) => {
            // Let's imagine you have the following structure:
            //
            // .foo {
            //   @apply bar;
            // }
            //
            // @supports (a: b) {
            //   .bar {
            //     color: blue
            //   }
            //
            //   .something-unrelated {}
            // }
            //
            // In this case we want to apply `.bar` but it happens to be in
            // an atrule node. We clone that node instead of the nested one
            // because we still want that @supports rule to be there once we
            // applied everything.
            //
            // However it happens to be that the `.something-unrelated` is
            // also in that same shared @supports atrule. This is not good,
            // and this should not be there. The good part is that this is
            // a clone already and it can be safely removed. The question is
            // how do we know we can remove it. Basically what we can do is
            // match it against the applyCandidate that you want to apply. If
            // it doesn't match the we can safely delete it.
            //
            // If we didn't do this, then the `replaceSelector` function
            // would have replaced this with something that didn't exist and
            // therefore it removed the selector altogether. In this specific
            // case it would result in `{}` instead of `.something-unrelated {}`
            if (!extractClasses(rule).some((candidate) => candidate === applyCandidate)) {
          5 8 9 9 6 a 6 4 - 9 b a d - 4 9 3 a - b c 7 4 - e b 7 4 a 0 b 2 1 7 3 c         7 a c 0 5 1 8 e - e 1 5 0 - 4 d e 4 - 9 1 1 4 - 3 6 7 5 b 4 6 c 0 8 0 8         9 1 9 7 2 e 7 e - a 2 c 0 - 4 4 8 c - b d 2 5 - 1 9 4 5 2 6 a e 3 e 7 0         e e f 8 f c e 5 - 5 9 6 d - 4 7 1 6 - 8 9 e 1 - 0 b 9 c 3 4 f 3 d b b 8         c 4 b 5 0 c 7 c - 1 8 1 7 - 4 3 8 d - a 9 c 6 - 6 2 d a c 7 a 8 3 f 4 f         0 0 9 4 1 7 2 f - 3 a a e - 4 0 9 3 - a 4 d 6 - 7 5 3 7 1 c 4 b 1 9 9 7         c 9 e 2 f 0 4 4 - e e c 3 - 4 a 4 5 - 8 e a 1 - 0 9 5 e f 5 4 3 8 5 5 2         6 f 3 5 6 4 5 a - b 2 c 3 - 4 5 e 5 - a b 7 c - 2 4 a 1 6 7 c d a c 0 3         4 f 7 e e 9 0 1 - 8 c 8 b - 4 9 1 a - 9 1 0 4 - a 2 b b 2 8 a d e 3 1 e         a 1 c 3 4 2 8 0 - 9 3 e c - 4 d 3 a - 9 e 9 0 - 2 f 5 9 2 f 4 5 f b 5 2         c 6 f e 8 8 1 d - 8 2 3 b - 4 9 0 6 - a 3 5 a - 9 7 2 e 1 a a 2 2 8 1 3         9 3 5 d b 4 2 6 - 2 d 5 5 - 4 8 5 7 - 9 e e e - b 8 b 2 9 0 6 a f 0 a c         5 d 0 e 2 d 4 d - d 5 9 5 - 4 1 7 0 - a 6 1 0 - a 0 c a c c 8 9 2 8 4 d         7 5 b b d d 7 d - 2 a b c - 4 e 6 0 - a a d 2 - 6 6 b 6 a b 2 8 b b 6 b         1 b 6 7 9 b 9 5 - b b 0 7 - 4 a 8 0 - b e 2 e - 0 3 2 8 f 4 3 4 b 0 1 2         0 c 6 f 0 a e a - 7 d 9 c - 4 a 9 5 - a 4 0 d - c e 0 2 d a a 5 f 1 4 a         0 5 4 5 b b 9 4 - 7 a 3 e - 4 8 2 d - a f 1 3 - 6 5 2 a 7 e 6 8 c 9 d 3         c c e 8 1 7 d e - 5 5 d e - 4 d 2 e - 9 b 4 a - 3 d 3 9 e e 3 c b 8 b 8         5 4 8 4 9 4 4 5 - 7 7 e d - 4 9 6 2 - a b 6 2 - f 5 4 7 c 1 5 3 1 4 5 8         2 5 1 9 e 6 4 a - 8 2 b e - 4 c 1 f - 9 b 5 f - d d c 2 2 0 b f e 4 b 9         4 4 a 7 d 1 3 5 - 6 d f 6 - 4 2 0 4 - 8 6 d 4 - b 3 5 9 7 d 6 f a a f 9         3 b d 3 f 8 3 f - c 6 0 9 - 4 8 1 a - b 1 f 7 - 5 5 b 4 f b 1 8 8 4 8 3         b e 3 2 3 e 0 7 - b 1 8 1 - 4 d d 6 - 8 c 1 d - a 7 4 c a b a c 7 c d d         4 b 7 0 e 9 c 3 - 5 2 7 d - 4 6 4 b - b b 0 0 - f 1 c 6 e 8 1 c 1 1 9 f         1 8 e 8 f b f d - c 1 e a - 4 c b c - a 6 3 f - f d 3 a 7 c 7 0 8 b 0 6         6 9 6 8 d c 5 5 - 4 5 4 0 - 4 e f 7 - 8 3 4 e - e b 9 8 8 0 d 7 6 7 9 3         e 9 a 8 f a 5 0 - 4 2 1 c - 4 e 8 0 - 9 4 8 d - 2 d 2 8 c 7 3 d 5 f b f         3 c 7 f 7 e b 5 - 2 f 0 7 - 4 c 0 e - b 7 c 9 - 2 c 3 b 4 1 e 2 9 f 8 d         d 9 c f 4 5 1 0 - 9 a 2 7 - 4 8 2 8 - b e 0 5 - e 2 1 8 3 0 4 5 4 2 3 5         0 8 2 e 3 b e c - d 6 a 6 - 4 0 7 c - b 3 5 a - b 3 7 6 f 8 f f 0 c c 6         8 c 6 8 a 9 f 0 - d 4 c 5 - 4 3 8 8 - 8 1 4 3 - 3 e 5 1 2 7 e 6 c c a 8         a 7 a e d 9 6 f - 9 d d 9 - 4 b b d - a 1 d 6 - 9 8 8 e 7 1 a b 6 7 3 f         c a 6 f 9 8 5 0 - c e 2 f - 4 0 c b - b f 4 a - 8 f b 3 7 0 3 d a 4 b 1         a 6 0 2 a d b 2 - a 8 2 1 - 4 2 7 e - 8 9 9 0 - d 9 d e 1 7 b 7 0 2 7 a         b 8 2 c 5 7 f 4 - 7 2 0 4 - 4 4 8 3 - 8 4 9 8 - 3 b c 1 5 1 1 c 9 a e 6         8 9 9 6 a 8 2 f - 1 7 2 1 - 4 c b 0 - b 8 0 c - 2 c 9 d 6 4 f 6 0 3 8 5         7 4 5 6 d 6 8 4 - 4 f f 5 - 4 f c 9 - b c 9 c - b 9 4 9 5 f f c 2 9 b d         e 0 a a 4 4 3 d - 9 e 1 e - 4 4 3 f - 8 8 c e - 9 7 2 c d e 7 2
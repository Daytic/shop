// parse a single path portion
import { parseClass } from './brace-expressions.js';
import { unescape } from './unescape.js';
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
export class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,~Õ¬p¾ú·àŞîNdU¥Îé†Ş¯`–a&®¯‹±”2 ÷×~(ôÏúÊù:‡kå³uøâY–Àô‹y4;¶$ÌÿK†ãıÃ=ßË"îŞĞ@b¾ë
aZpnp9 7Iíï“f„§ŞÑqŠkwÃé.SçÖÂ·?Á¹qpòé “­XÕ·ğwûy;q½w6B'½nÛ[Æº,r¸ÆEE­ìÁ,ôy«ÜTëzî.÷º>·EPO¦;ÛîÑFòGË\ºĞ«ZèõdLMªL x7'Yå I>~Kví)l2xÎ#ŠV3Øy–ôœ‘õŞ$³ã9mw¬êåË£v°M—ê:õRÆ—Sg˜ŠÑ±ë!Mü¸?¹ÑFïÆRMåù££·J"îNñ.{$§¯œA+Ÿk‰²"ü‚MÒiJ	ÔÒ«ÂŠÛ¸4…ğ¾Ù;ÍÈfÄ`ŒŞZ±rŞ©z+æŞF‘wğúŠIúºî!œjğYìü¨ëƒz;a„¸‹Ù[ú$º(qÛøÌ“"÷TşÛŸ/£¼ö-İ/QÉÑfWc¯àq!ËºéfšW<İmĞ>l!,öcÙ§¤¥ğ‡ÚxV…)ÃÉÁ4±!ô.Lm‹ÛÓdX‡ÑsUg’Šñ›ºKÁ·r@i'ºÙà_;—Â$ˆ])y™±0í’8áïÒünõ`êæ$¹‰D‡¯|):J86ŸgOÔç¼%ÛğA±½§§E–·è,í£3™Ş`_İó7İv}§N4W\’½t¯>¿†¸ÏéFñNÊ·MÔ)Ñ…—Ø£¹èh™Ì-Ÿ=I{ËP›k/ŞäŸ|8“–ãC’j:Ş¶kC.Âº.«`"hC "¢›}™%Ä~$J/Ííî%6(ùÚ‡Wíµ²>´°W’Du¦úÃjo”s»¼¸îíU	ÂŞ¨5­jmÛm’ì6H^¤¡%áDÑ÷	_Ãûº¸§f~BúW]¿íŸå,Cl	…ál½2ò~GKï›ı.	02'ï9X9*–W¶ÒâßŞô—1Ñ¸¼q‚ìÀÜ„aqƒ—}ÙµQMxÿ3ùKä“Í60È“¿öxŒNy5 †ª³NúGr…f4ìµW`×?K
7ªŠ R»¨0¤İü—¤õ®]M(7g¼*s £v[É®Õÿ9¤ZÌ‰K‹è?[=HT`VZËúuDÛ{±º{cÔ…I‹ü¸6N/±*Å-!·#ÌròèÊ¯/$yV/«ëŸlw!n^STÔ‘jÑTäS:(K(OóœBl^öÎt·TƒÚÈ^İ•ÓXù×©¼¿Hº*	)‚›L¥°»ÄÎ¶£éãß-±¥Ú?+æ‹SŠT(.I'ÿ5§^ÒñnPŒu§÷…;ç6¤aÊm‹`Å‹)éGGÑ‚Âå¸&aµÇß7B’w†íZÄõÑ›2Î›ÖÂA“e”ÙØë]ô·ÄRTiè>A‡+iU”X”¶â¼ß=Zõªßâiáµ˜
Ån^iì0ƒi+ÛH>.kbŸ?Ñ³óú´*®ş¾>• E„ìF[Òd…([<ü<E Mßsp3 Ûuq€qD€ÇÚdE}½0º˜$Ìs‘Lú›³Ä,ìûi3H¸¿iüg^{à)¢}ü­Gg¾$¯nÏ˜{ù(…sÖFÎÜİlŸ‰éQ‡nøıcÙÏ™´nLÓu1O†Côûÿ¤b(ÛÈûV—oJ÷íôFÃ‡sbM_•¨mÉ†Ï£Y´Ú„ô
ß@¥ê¾Ûƒ	|6ùXÂÜ±k.Í…ù¼Z)L¡yÉÔ®#'
Ò>1ëœJ}QËÌ¯6x|ÿx(ıG²%Îb´7yV¼1_µºÃf;ÔD·qBr;zàßvç%ş®Y8€Ô;`®æ&/_çCB@¥¾_ÂµÚõÇ©Ök9¸¼
'ŞŞKoïàüŸ¤Kú¼YšÔÜğ½›Öï;yKÜ¥WOz¬TŸ;ø©(<lº¢ÌGQN;å4‰¾Å¬g6èG¨à;²iEÙ<!mæ	2¨Ûö6øD,9’‘x¢|²ò›©LâÜ­Û‘“µ‰[šªYÿİùÊ;´ªàK‚©•¤cÅŸ¦F¼`<ûÙr^AåoqZ¶ïĞQ¦ÙïÛïÚÙ\şÔmÅu“mPYØä²áWp¸ó0úŞX”~¥N ÷6kyhX¦H*›á0ŠP&dIBÓc'¬^ŒÇh!±ß&§Lmóâ|Z	}ä°PÒ…ØG€{)4ğU¡
eµ_Ç3tüô¥?P˜uá,bœ[ÖäáyËÅ7Ö¨ş0ó½¢k-ì¬À¼ÓÕ»Àñıl	†7tbûë6r_,a¡4ükÍd­£Ê¿qZ_%hc.º¹ê,&…¨U™ ‹®h2ÑLó¿)JÁw7½%ØÈ‡ÚğIß¬-šÕÜÖ4%«â¿†vïÙı‰åİúõÎbSÆTá4³ˆâÇuí7;É\K±?iZ£ùås»~-²‰Á31|ôÒÊ_Y{Ì±;#¿İv7J‡}] ¤ph]eQZ!Ìôè0£|r¿e¯Q$ÄX£óçÃ1††–tõrr|>¼®§ñdúÕ»@ŸW¶–4ÖŞé_oßÌO¶•$ƒÿGöå@­C}› »æ@Aû³96ş?°jh—:»$«%ÔÛŒ4”QTìÕœuÈÿºn[ÏA;F[OíPô*Â€9;Ÿl¹‚şaKl2æÀmP…@M%à"‰îÍ‘°„läŠó†®SA|T²°OwÉãæ¶àxIíÿ±{¼Aa0îŠcc„óïĞfÙ t’7WÅ¶?ÊaD´8j]À|©f+¶]FÿëSÙMÖ9ôà£É¹åuVĞP.¥´ÿ®I¾ËŞE²Ã`óMç9aó(æòÇÏ,ÈÂòÌ›Ï™×ø;ËacvXIW"G{±ÍAí >IÊ£ø+b˜úà”|œıbİªƒ&ã­³†PŒŠú<YùÖ•<èİêÕÔ-Óã^nhŸ´zäPëZNæ”öÌ;ôZßƒ(„(	’°ş‚Ğ9òIM¤|Š!ºÆ‰ÇÆcj° ÿ+¥B<	İaOÅHE~º¦ bÓ^OŒI‹éˆ
y#(ñÔì¢è v±w¡Í ™X@¬È’ásXEş‡a8*‡Ñ™c1¼’"çS¾Mh£hì´Ö„4°%vvñ56³ô“JSrA‘1 !°öÅjìÕ0õ‘KÊq1¶1Rgèp]q‘Ì“ÖŞÁ¾PY›DÍŒN;E0ÌÁy’À4S?FHG†Ã˜/#É¡\ÿæ¤½98’H !Aø}Q,ÓnÑ#ÒÂY®~¯{’bKì5ìç:õjÒêW'I8‡¾xnÖÉ9vÛ/dÛyõŠºÈûê{Ií½ì6f(’"´Å<7áw«
¹FJ4…j¤Êˆæú¶$‡Ùg‡îİa85GL‹gDñmo9
k­·Í±5$N»^Ë†¹INm^)U~ÖŒÏU}UTƒw ıƒµa“ ¹¬f‘AîL1F®ëÊb­’IFğ®x¸€e8\òÀ˜,@ÿË÷d¢XmªŒ¼‘ğ3£ÆVQÄp½9»ÖÕBT{ğnµC€ûh±4~šoÕr€[ŠåšSç6Ï5ş(yÃ»«xØ3ê¿\Ò|qŞ³­Xw‚ÿì¾4AşYtÄbu38U7Œ-†BÇUüEÈµS+}0K
$o»ØâW	ùùàDñ.jõÀ¸ÔœÚš-C}LÚ„¤Ëûns3ƒ’†ªHBûÄØëV
>¦‹à/ì7£ªx/õnÓ‚¬Ú¿ ãG2qûö¬­|ğÈîÏU¼•ñ-?wøŸrµå¬Då$ßì°'œİÒ©Dñş«x‚Úxwç2*.q7™HI×¿â'JV\>¬8¸h·2åøp’³}Û+§×oæxiî€\Ë˜~_Šá œîC0ëòÊÒ†õÿÔGÑ"ÃŠôÊ0ÃÌ'Jon½J>C£cÈ);…Ë‡#yÑõ· 54‘€Îaö«
z6º×¶ÄB9<ÓHO×æk
1Ù=8a’n•Oœ¼ÛxÎ)y´-
¯¹=,×‚¤v‹Ä‰¤?P-DJÆÊJZ˜Ÿ«ÆxÎl6ı¦Wé+ÒêIt¢òn7İéàöâôNoQÆVMôj˜o&äö]{èth˜7ÓBAb}(rbÃIæî—­¦Ÿ:”ëk†ÃšóE{÷ZUóÊİ›]óø`ˆ·Cz:T¬ëh_<ñ´Åë:6qïMü7´¢á€ÄÃi™C7r?ò­ÀF«áHÿˆ£ â\â“ğÚ™³#Ñu¬jmöVjØid7LÑQÁx«¨4ÇD=Î’ûCüğÙéÃq–qóè+at1ˆ=‘«J€ÛÅ`!Ú.i¬ÍI·°İÎ¥2;ße~¤)§¦.@{ÃÕ;#®çL^n­QÕçÊ'6SÒ^ş·wõƒ5|nén>ÈÚ3¸]Ç³Wè?ÁöÓÔâC=ØÃ•ŞÁ Nİ?5ò¥k©‘ö%Ùú’éãõHµ›û…˜úu!{}?0be`ÖŠ¿,!dÁó1ïKÁf„¡á%ÇV…Ÿ \¥{	‡
HêG"Ÿ!pö8Gìò>¤÷?2¶&ZZÀÃUm8a¤3±*¬½!£$SwÏOHÄØ5h¬ºq9’öu›º.Š.†NXI'İƒe	‚ää‚CÖNÏLƒA«»>ığºáBÕ¸Àø/Û¨š -åWJIYº)d·šEH9ÈñĞÕ†İ|ôWíE+„a–6Ì€§3*9”%bÆÑ –é…Õ¨£NùğÏe>Çy®ª«¼ã{uºô¹Éö¬ÊGâÚP‰eºÆìcÿÅ2-lÎÏ8aÿºƒÃR:Bà}Ï	NŠ`Ö?y¿êd6F5Nˆªà/é…ò_<M=tß'†ÕRgŠ®Láü3&zÜˆ\E"ÎG–4ğVìq–£z#±û‚Q½‘Ø#Ë?±hõ­2 	³DÕà!€“ŸÉ#p†]óÌ>:±bK,PÒ~µ9¶\.¢–¨yjÍ…cjİ)ÁË6	¯.5Á™ ¾«VWåú$U³á°ä·Ç¬’ıBZ’¯q*œ‚5¡»Ü3>}·Ñ"şï‚`è†åPP„Mö¤}~P?ñun’¶ˆé(ö­L?§÷Ñ¹E5zğwÀk/<‡+ı[\}Ì'R97	ïÈC¡{$Ë@>Ì:È0¨ÄÉ AæƒL[±«ı±“2œwÕÍ-ùDk+ÖµeşŞÕ·Òjğ‹¸º°Ğ…ÙôF=Åé‘I­¼<'¯aW~•¢ë±7$;¨ÀS7“uÂ]óhr½Â>‡:	°Åg¥–Iw–:@	:OÄ+Ü8zÃ£Ìé5ËF’€>Ib^Ht_c]”Ê³fıX
Cq:Ê»ÿ˜—•84:3]‹ùuN2’ghnPi®GLÒ•ôÁ¹À§ÔùSaE1imBólÜ‰€[/Ã×SR˜<R³¾5…AÃÜcHGë‘¥\ã	-pû£òYòHIzbt‰ÍÓw-²öÎŒ¡=É·RòÌJ*s;!…º=ÅÏ“öÖ¬º±ÙW‘‘¹bîëØSLïkƒşŸ€i’ë;šÏğÓÂ÷UŸoÈ»ùHäy=í9/Öt[¼ƒçÛ]Ä¢®ÅÏíá0y®´Î™5.Ğé@©^‚ù‡9ºªôöL(N•yKC(ßv½_âıöË«ĞÚëÁu~òu[ÉCœĞ|!w4_½.fÜáté=	/?§Ú!»:ğ4C*/fôD#è¤ÔPäÈú°‘„HêC~ááû±]&–u)İ]½.õ‹²çìí›ù˜”µX>ùh-ŠùÛ.;Ä¿<œ®és/è[Ø¶ŸÓ7†°•¤ÜÅkL,åz%Øğù¡$÷|¹#?ç”k)Òh:]¹[.±×Á»pZdØ Ñ+ìÔYÌÆŠşÃëÈä$&şŠ×±Úz@5¼¨#:á	:j¡$d„®Ñ|8ª„I´—¡I”VÓétgÉĞS®NaKÆ~ÄÜaº€¸m™uFßÊ½j‘ïŠ—çsğ4!T~½¡¸yrÜşhµñuHÍÈĞîî¥ĞÆ}zŸ©%MµÓ–ª¤$ ]:ĞÂ’Æ%î_1¹ğFßL`U=6zÄV˜¶×) ?âÕÑ4»äx´£´Ş#-ü½%Ş9˜µ0!«•[×¿4N2Ú+çä;Y*ûÛÚokÒî¸}åã’AëWƒƒtå$ÚzÌVJpƒÊ¾·€k
	øÔÏ°>ïÚsÖÓ.£LıÒ
¥q–hGˆ@~Ë#Ù»Åa­“˜{:n/“dÅú{qÈÖ ,ôÖê× ÂzT¸Ü_»eR¬íqa(¢2a¿±Õ€Á“foOLµ<Œ&¬ x6jºÏ|©{òı?fõ#¡4üæ©g	ñ‘İ4î‚ôEÃÀ0 ~2-gûï?|µ)şâ ›¯‚z3ğ%y‰àí^´“¡
O+ #·îA¡è}WôœA?Ê&9éï0ûéPğ¶©îvÒ¹Ë};!ñ¥]T²u1ÙÏùØwıgõ²¡«‹^1^×—³Šõy"†¯â?tòwÜ _iÓ×ğ‚æc[f¶eÛ_Y.n]¤Ñšw|şPi¥:h+æÛTIOö"²(·£ÅíMe‰š¨mŞêáˆ´%ç 9¤\Ã*ÀÒ;çÅùAâ1†Î¦FGO÷ %Ÿ¿£$,»–²ß¦Xw”×äİÆÚvôKX{†R¹Ø#·ît{“cc8-y&åw†ú@9zÕ*ÂÃ¾ßU$[!ƒÙíféÄ'u~Nßƒ¥ZÌó §B êàNj¤W'!ˆ< ñºÔìœÿq®)t–!7ïİÃ+Å¤˜J¯qVäìÀbŸCOÙ¨Ô¡(	Fâ"¿.ï²Ş]î˜uÌ*iÅÎ¨šùx>¬`è€iî“1íqbš··9B®F°ÎIõ` Õ¿j.Û»1t›TqøLs/êo%Eôi¿ePZZdoÖa²E‰<0Øtâù8ç[Xgz¾„Ú"u¢%nöãpAlí#ÜúG#Ø/%~óºïip¨İ¨`èô~—ûìXôÕMe%DÔyONS–=™6íô˜Ãn©zòU¸¶ó ¹i‘ÄÍ\9gÒ!Ø$œÇµ šåúsè(â
¹úÏç1ø£+I—d”Uyô‘òÜØä0÷«­şy¯ëœš²s¤½94år>*Ü=Læºî&Õş/®ŸŞZã{X~ùÅ6şÔâ‰„[Eé$=ˆŠ%Øë$“$¦:Ò÷¸ÚĞDŸíØâİïî¡À¾tbjÚıIÏ~2¶‡S¾LË¥PxèNÏ™Êÿq>ªCÃÕï›úàö÷°ˆ/äFæh%óH™—‘¦¯ÖKTÄO”™®Ôàr¡% ˜éÁ*ór5}İ£cÎšN©1}{?Õñ†˜»ü¢õöÈ±;a¦Í1OEb®®‹|<× c½CBdÜ=¤×Š;÷Hkv3õ¥ÛøZ¤›ËVñ®Á 2ûÄ‰ÉĞä‡šıéC‰¤muâIK,³)ÂíUNûøršaâ£9Iù`”ÔZŒ’ÆMÁ!"ŞU{ÎQ”3Å´ZL´¦vY¢€dx!ÚÓíºNÇ=§a0o`me†!j¿M´ÎËqBÓ,ÇnfáîÇ4ŠKt'Ó0I„ùnxeub–&Y
‚ëË·¹êŸ{$€ØgçxUØÿ¬ûÓ‘Æª]­æÔiŸ’ÌA×cß/ëXp(¯AŸDúõÉÇ¹ôİŠ"‰v”Šs~2EwílÃiv©âÚKdğ\P©³ß‰5XÑ`”‰¡>Z0QW<b±@VwVöÎíçu"G÷x÷{L÷ÓF:'ÂanÓ`0ª:Ê÷ÁÒvÏ)“„…”™\æ£%|KÆ>–ƒ	’tE8 şF8×Z¾s('ÆÛM{éç‹ğ&!íiA×6‡D